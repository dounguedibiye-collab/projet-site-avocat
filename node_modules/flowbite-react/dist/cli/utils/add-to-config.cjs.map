{"version":3,"file":"add-to-config.cjs","sources":["../../../src/cli/utils/add-to-config.ts"],"sourcesContent":["import MagicString from \"magic-string\";\nimport { parseSync, Visitor } from \"oxc-parser\";\n\n/**\n * Simple builder-like interface for backward compatibility\n */\nexport const builders = {\n  stringLiteral: (value: string) => JSON.stringify(value),\n  identifier: (name: string) => name,\n  callExpression: (callee: string, args: string[]) =>\n    args.length > 0 ? `${callee}(${args.join(\", \")})` : `${callee}()`,\n};\n\nexport type ValueGenerator = (b: typeof builders) => string;\n\ninterface ArrayLocation {\n  start: number;\n  end: number;\n  elements: Array<{\n    start: number;\n    end: number;\n    value?: string;\n    type: string;\n    name?: string;\n    calleeName?: string;\n  }>;\n}\n\ninterface ArrayStyle {\n  isMultiLine: boolean;\n  indent: string;\n  elementIndent: string;\n}\n\ninterface PropertyCreationInfo {\n  insertPosition: number;\n  propertyPath: string[];\n  needsComma: boolean;\n  indent: string;\n}\n\n/**\n * Modifies the given content by adding a value to a specified path within the content.\n */\nexport function addToConfig({\n  content,\n  targetPath,\n  valueGenerator,\n}: {\n  content: string;\n  targetPath: string;\n  valueGenerator: ValueGenerator;\n}): string {\n  const parseResult = parseSync(\"config.ts\", content);\n\n  if (parseResult.errors.length > 0) {\n    return content;\n  }\n\n  const valueToAdd = valueGenerator(builders);\n  const pathParts = targetPath.split(\".\");\n\n  const configObjects = new Map<string, { start: number; end: number }>();\n  let targetObjectStart: number | null = null;\n  let targetObjectEnd: number | null = null;\n\n  const collectVisitor = new Visitor({\n    VariableDeclarator(node) {\n      if (node.id?.type !== \"Identifier\" || !node.init) return;\n      const varName = node.id.name;\n\n      if (node.init.type === \"ObjectExpression\") {\n        configObjects.set(varName, { start: node.init.start, end: node.init.end });\n      } else if (\n        node.init.type === \"CallExpression\" &&\n        node.init.arguments?.length > 0 &&\n        node.init.arguments[0]?.type === \"ObjectExpression\"\n      ) {\n        configObjects.set(varName, {\n          start: node.init.arguments[0].start,\n          end: node.init.arguments[0].end,\n        });\n      }\n    },\n  });\n  collectVisitor.visit(parseResult.program);\n\n  const findExportVisitor = new Visitor({\n    ExportDefaultDeclaration(node) {\n      const decl = node.declaration;\n      if (!decl) return;\n\n      if (decl.type === \"ObjectExpression\") {\n        targetObjectStart = decl.start;\n        targetObjectEnd = decl.end;\n      } else if (decl.type === \"Identifier\") {\n        const obj = configObjects.get(decl.name);\n        if (obj) {\n          targetObjectStart = obj.start;\n          targetObjectEnd = obj.end;\n        }\n      } else if (\n        (decl.type === \"TSAsExpression\" || decl.type === \"TSSatisfiesExpression\") &&\n        decl.expression?.type === \"ObjectExpression\"\n      ) {\n        targetObjectStart = decl.expression.start;\n        targetObjectEnd = decl.expression.end;\n      } else if (decl.type === \"CallExpression\" && decl.arguments?.length > 0) {\n        const arg = decl.arguments[0];\n        if (arg?.type === \"ObjectExpression\") {\n          targetObjectStart = arg.start;\n          targetObjectEnd = arg.end;\n        } else if (arg?.type === \"Identifier\") {\n          const obj = configObjects.get(arg.name);\n          if (obj) {\n            targetObjectStart = obj.start;\n            targetObjectEnd = obj.end;\n          }\n        }\n      }\n    },\n\n    AssignmentExpression(node) {\n      const left = node.left;\n      if (\n        left?.type === \"MemberExpression\" &&\n        left.object?.type === \"Identifier\" &&\n        left.object.name === \"module\" &&\n        left.property?.type === \"Identifier\" &&\n        left.property.name === \"exports\"\n      ) {\n        if (node.right?.type === \"ObjectExpression\") {\n          targetObjectStart = node.right.start;\n          targetObjectEnd = node.right.end;\n        } else if (node.right?.type === \"Identifier\") {\n          const obj = configObjects.get(node.right.name);\n          if (obj) {\n            targetObjectStart = obj.start;\n            targetObjectEnd = obj.end;\n          }\n        } else if (\n          node.right?.type === \"CallExpression\" &&\n          node.right.arguments?.length > 0 &&\n          node.right.arguments[0]?.type === \"ObjectExpression\"\n        ) {\n          targetObjectStart = node.right.arguments[0].start;\n          targetObjectEnd = node.right.arguments[0].end;\n        }\n      }\n    },\n  });\n  findExportVisitor.visit(parseResult.program);\n\n  if (targetObjectStart === null || targetObjectEnd === null) {\n    return content;\n  }\n\n  const result = findTargetArrayOrCreationPoint(content, targetObjectStart, targetObjectEnd, pathParts);\n  const s = new MagicString(content);\n\n  if (result.type === \"found\") {\n    const targetArrayLocation = result.array;\n    const exists = checkValueExists(targetArrayLocation, valueToAdd);\n    if (exists) {\n      return content;\n    }\n\n    const arrayStyle = detectArrayStyle(content, targetArrayLocation);\n\n    if (targetArrayLocation.elements.length > 0) {\n      const lastElement = targetArrayLocation.elements[targetArrayLocation.elements.length - 1];\n\n      if (arrayStyle.isMultiLine) {\n        // Multi-line style: add on a new line with proper indentation\n        // Check if there's already a trailing comma after the last element\n        const afterLastElement = content.slice(lastElement.end, targetArrayLocation.end);\n        const hasTrailingComma = /^[\\s]*,/.test(afterLastElement);\n\n        if (hasTrailingComma) {\n          // Find where to insert (after the comma)\n          const commaOffset = afterLastElement.indexOf(\",\") + 1;\n          s.appendLeft(lastElement.end + commaOffset, `\\n${arrayStyle.elementIndent}${valueToAdd}`);\n        } else {\n          // Add comma and new element on new line\n          s.appendLeft(lastElement.end, `,\\n${arrayStyle.elementIndent}${valueToAdd}`);\n        }\n      } else {\n        // Inline style: add with comma and space\n        s.appendLeft(lastElement.end, `, ${valueToAdd}`);\n      }\n    } else {\n      // Empty array\n      if (arrayStyle.isMultiLine) {\n        s.appendLeft(targetArrayLocation.start + 1, `\\n${arrayStyle.elementIndent}${valueToAdd}\\n${arrayStyle.indent}`);\n      } else {\n        s.appendLeft(targetArrayLocation.start + 1, valueToAdd);\n      }\n    }\n  } else if (result.type === \"create\") {\n    const { insertPosition, propertyPath, needsComma, indent } = result.creation;\n    const indentUnit = detectIndentUnit(content);\n    let newContent = \"\";\n    const lastIndex = propertyPath.length - 1;\n\n    for (let i = 0; i < propertyPath.length; i++) {\n      const key = propertyPath[i];\n      const currentIndent = indent + indentUnit.repeat(i);\n\n      if (i === lastIndex) {\n        newContent += `${currentIndent}${key}: [${valueToAdd}]`;\n      } else {\n        newContent += `${currentIndent}${key}: {\\n`;\n      }\n    }\n\n    for (let i = propertyPath.length - 2; i >= 0; i--) {\n      const currentIndent = indent + indentUnit.repeat(i);\n      newContent += `\\n${currentIndent}}`;\n    }\n\n    const prefix = needsComma ? \",\\n\" : \"\\n\";\n    s.appendLeft(insertPosition, prefix + newContent);\n  } else {\n    return content;\n  }\n\n  return s.toString();\n}\n\ntype FindResult =\n  | { type: \"found\"; array: ArrayLocation }\n  | { type: \"create\"; creation: PropertyCreationInfo }\n  | { type: \"none\" };\n\n/**\n * Find the target array at the given path within an object,\n * or return creation point info if property doesn't exist\n */\nfunction findTargetArrayOrCreationPoint(\n  content: string,\n  objectStart: number,\n  objectEnd: number,\n  pathParts: string[],\n): FindResult {\n  const objectContent = content.slice(objectStart, objectEnd);\n  // Wrap in parentheses to parse as expression, not block statement\n  const wrappedContent = `(${objectContent})`;\n  const parseResult = parseSync(\"temp.ts\", wrappedContent);\n\n  if (parseResult.errors.length > 0) {\n    return { type: \"none\" };\n  }\n\n  // Offset adjusts for the leading \"(\" we added\n  const baseOffset = objectStart - 1;\n\n  interface ObjectInfo {\n    start: number;\n    end: number;\n    properties: Array<{\n      key: string;\n      start: number;\n      end: number;\n      valueType: string;\n      value: unknown;\n    }>;\n  }\n\n  function extractObjectInfo(node: unknown): ObjectInfo {\n    const obj = node as { type: string; start: number; end: number; properties: unknown[] };\n    const props: ObjectInfo[\"properties\"] = [];\n\n    for (const prop of obj.properties || []) {\n      const p = prop as {\n        type: string;\n        key: { type: string; name?: string; value?: string };\n        value: { type: string; start: number; end: number };\n        start: number;\n        end: number;\n      };\n\n      if (p.type !== \"ObjectProperty\" && p.type !== \"Property\") continue;\n\n      let propKey: string | undefined;\n      if (p.key.type === \"Identifier\") {\n        propKey = p.key.name;\n      } else if (p.key.type === \"StringLiteral\" || p.key.type === \"Literal\") {\n        propKey = String(p.key.value);\n      }\n\n      if (propKey) {\n        props.push({\n          key: propKey,\n          start: baseOffset + p.start,\n          end: baseOffset + p.end,\n          valueType: p.value.type,\n          value: p.value,\n        });\n      }\n    }\n\n    return {\n      start: baseOffset + obj.start,\n      end: baseOffset + obj.end,\n      properties: props,\n    };\n  }\n\n  function processPath(objInfo: ObjectInfo, remainingPath: string[], depth: number): FindResult {\n    if (remainingPath.length === 0) {\n      return { type: \"none\" };\n    }\n\n    const key = remainingPath[0];\n    const prop = objInfo.properties.find((p) => p.key === key);\n\n    if (!prop) {\n      const lastProp = objInfo.properties[objInfo.properties.length - 1];\n      const insertPosition = lastProp ? lastProp.end : objInfo.start + 1;\n      const needsComma = objInfo.properties.length > 0;\n      const beforeObj = content.slice(Math.max(0, objInfo.start - 50), objInfo.start);\n      const indentMatch = beforeObj.match(/\\n([ \\t]*)$/);\n      const indentUnit = detectIndentUnit(content);\n      const baseIndent = indentMatch ? indentMatch[1] : indentUnit;\n      const indent = baseIndent + indentUnit.repeat(depth);\n\n      return {\n        type: \"create\",\n        creation: {\n          insertPosition,\n          propertyPath: remainingPath,\n          needsComma,\n          indent,\n        },\n      };\n    }\n\n    if (remainingPath.length === 1) {\n      const value = prop.value as { type: string; start: number; end: number };\n      if (value.type === \"ArrayExpression\") {\n        return {\n          type: \"found\",\n          array: extractArrayLocation(value, baseOffset),\n        };\n      } else if (value.type === \"CallExpression\") {\n        const arr = extractArrayFromCallExpression(value, baseOffset);\n        if (arr) {\n          return { type: \"found\", array: arr };\n        }\n      }\n      return { type: \"none\" };\n    }\n\n    const value = prop.value as { type: string };\n    if (value.type !== \"ObjectExpression\") {\n      return { type: \"none\" };\n    }\n\n    const nestedObjInfo = extractObjectInfo(prop.value);\n    return processPath(nestedObjInfo, remainingPath.slice(1), depth + 1);\n  }\n\n  let result: FindResult = { type: \"none\" };\n\n  const visitor = new Visitor({\n    ObjectExpression(node) {\n      if (result.type === \"none\") {\n        const objInfo = extractObjectInfo(node);\n        result = processPath(objInfo, pathParts, 0);\n      }\n    },\n  });\n\n  visitor.visit(parseResult.program);\n\n  return result;\n}\n\n/**\n * Extract array location from an ArrayExpression node\n */\nfunction extractArrayLocation(node: unknown, offset: number): ArrayLocation {\n  const arr = node as { start: number; end: number; elements: unknown[] };\n  const elements: ArrayLocation[\"elements\"] = [];\n\n  for (const el of arr.elements || []) {\n    if (!el) continue;\n    const e = el as {\n      start: number;\n      end: number;\n      type: string;\n      value?: unknown;\n      name?: string;\n      callee?: { type: string; name?: string };\n    };\n\n    const elemInfo: ArrayLocation[\"elements\"][0] = {\n      start: offset + e.start,\n      end: offset + e.end,\n      type: e.type,\n    };\n\n    if (e.type === \"StringLiteral\" || e.type === \"Literal\") {\n      elemInfo.value = String(e.value);\n    }\n\n    if (e.type === \"Identifier\") {\n      elemInfo.name = e.name;\n    }\n\n    if (e.type === \"CallExpression\" && e.callee?.type === \"Identifier\") {\n      elemInfo.calleeName = e.callee.name;\n    }\n\n    elements.push(elemInfo);\n  }\n\n  return {\n    start: offset + arr.start,\n    end: offset + arr.end,\n    elements,\n  };\n}\n\n/**\n * Extract array from a call expression like [].filter(Boolean)\n */\nfunction extractArrayFromCallExpression(node: unknown, offset: number): ArrayLocation | null {\n  const call = node as {\n    type: string;\n    callee: { type: string; object?: unknown; property?: { name?: string } };\n    start: number;\n    end: number;\n  };\n\n  if (call.callee?.type === \"MemberExpression\") {\n    const obj = call.callee.object as { type: string; start: number; end: number; elements?: unknown[] };\n    if (obj?.type === \"ArrayExpression\") {\n      return extractArrayLocation(obj, offset);\n    }\n  }\n\n  return null;\n}\n\n/**\n * Detect the indentation unit used in the file (tabs or spaces, and how many)\n */\nfunction detectIndentUnit(content: string): string {\n  // Look for common indentation patterns\n  const lines = content.split(\"\\n\");\n  const indentCounts: Map<string, number> = new Map();\n\n  for (const line of lines) {\n    const match = line.match(/^(\\s+)\\S/);\n    if (match) {\n      const indent = match[1];\n      // Check if this looks like a base indent (not nested)\n      if (indent === \"\\t\") {\n        indentCounts.set(\"\\t\", (indentCounts.get(\"\\t\") || 0) + 1);\n      } else if (/^ +$/.test(indent)) {\n        // Count spaces - try to find the smallest common unit\n        const len = indent.length;\n        if (len <= 4) {\n          indentCounts.set(indent, (indentCounts.get(indent) || 0) + 1);\n        }\n      }\n    }\n  }\n\n  // Find most common indent\n  let bestIndent = \"  \"; // default to 2 spaces\n  let bestCount = 0;\n\n  for (const [indent, count] of indentCounts) {\n    if (count > bestCount) {\n      bestCount = count;\n      bestIndent = indent;\n    }\n  }\n\n  // If we found tabs, use tab; otherwise use the detected space count\n  if (bestIndent === \"\\t\") {\n    return \"\\t\";\n  }\n\n  // Try to determine the base indent unit (2 or 4 spaces typically)\n  const spaceCounts = Array.from(indentCounts.entries())\n    .filter(([k]) => /^ +$/.test(k))\n    .map(([k, v]) => ({ len: k.length, count: v }));\n\n  if (spaceCounts.length > 0) {\n    // Find the GCD of all space lengths to determine the unit\n    const lengths = spaceCounts.map((s) => s.len);\n    const gcd = lengths.reduce((a, b) => {\n      while (b) {\n        [a, b] = [b, a % b];\n      }\n      return a;\n    });\n\n    if (gcd === 2 || gcd === 4) {\n      return \" \".repeat(gcd);\n    }\n  }\n\n  return bestIndent;\n}\n\n/**\n * Detect the array formatting style (inline vs multi-line)\n */\nfunction detectArrayStyle(content: string, arrayLocation: ArrayLocation): ArrayStyle {\n  const arrayContent = content.slice(arrayLocation.start, arrayLocation.end);\n  const indentUnit = detectIndentUnit(content);\n\n  // Check if the array spans multiple lines\n  const hasNewlines = arrayContent.includes(\"\\n\");\n\n  if (!hasNewlines || arrayLocation.elements.length === 0) {\n    // Inline style: [a, b, c]\n    return {\n      isMultiLine: false,\n      indent: \"\",\n      elementIndent: \"\",\n    };\n  }\n\n  // Multi-line style - detect the element indentation\n  const firstElement = arrayLocation.elements[0];\n  const contentBeforeFirst = content.slice(arrayLocation.start, firstElement.start);\n\n  // Find the indentation of the first element\n  const indentMatch = contentBeforeFirst.match(/\\n([ \\t]*)$/);\n  const elementIndent = indentMatch ? indentMatch[1] : indentUnit;\n\n  // Determine the array's base indent (one level less than elements)\n  let arrayIndent = \"\";\n  if (elementIndent.startsWith(\"\\t\")) {\n    arrayIndent = elementIndent.slice(0, -1);\n  } else {\n    const unitLen = indentUnit.length;\n    if (elementIndent.length >= unitLen) {\n      arrayIndent = elementIndent.slice(0, -unitLen);\n    }\n  }\n\n  return {\n    isMultiLine: true,\n    indent: arrayIndent,\n    elementIndent,\n  };\n}\n\n/**\n * Check if the value already exists in the array\n */\nfunction checkValueExists(arrayLocation: ArrayLocation, valueToAdd: string): boolean {\n  return arrayLocation.elements.some((el) => {\n    if ((el.type === \"StringLiteral\" || el.type === \"Literal\") && el.value !== undefined) {\n      try {\n        const parsed = JSON.parse(valueToAdd);\n        return el.value === parsed;\n      } catch {\n        return false;\n      }\n    }\n\n    if (el.type === \"Identifier\" && el.name) {\n      return el.name === valueToAdd;\n    }\n\n    if (el.type === \"CallExpression\" && el.calleeName) {\n      const callMatch = valueToAdd.match(/^(\\w+)\\(/);\n      if (callMatch) {\n        return el.calleeName === callMatch[1];\n      }\n    }\n\n    return false;\n  });\n}\n"],"names":["parseSync","Visitor"],"mappings":"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"}